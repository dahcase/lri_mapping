tm_shape(afro) + tm_borders() +
tm_shape(plotdat) + tm_dots(col = "water", palette = color_pal)
library(MASS)
?mvrnorm()
matrix(1,2,3,4)
?matrix
matrix(data = c(1,2,3,4))
matrix(data = c(1,2,3,4), nrow = 2, ncol = 2)
cov <- matrix(data = c(1,1.25,1.25,2.5), nrow = 2, ncol = 2)
cov
?mvrnorm
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
mvrnorm(2, mu = c(3,5), Sigma = cov)
for (x in 1:100) {
y <- beta1*x + beta2*x
}
beta1 <- 3
beta2 <- 5
for (x in 1:100) {
y <- beta1*x + beta2*x
}
#Let us Assume the following model:
# beta1 mean = 3 with variance 1
# beta2 mean = 5 with variance 2.5
# beta1 and beta2 have a covariance of 1.25
cov <- matrix(data = c(1,1.25,1.25,2.5), nrow = 2, ncol = 2)
beta1 <- 3
beta2 <- 5
results <- c()
for (x in 1:100) {
y <- beta1*x + beta2*x
results[x] <- y
}
results
betas <- mvrnorm(1000, mu = c(3,5), Sigma = cov)
betas*3
betas*3 + betas*5
rowsum(betas*3 + betas*5)
apply(sum, 1, (betas*3 + betas*5))
apply((betas*3 + betas*5), 1, sum)
betas <- mvrnorm(1000, mu = c(3,5), Sigma = cov)
head(betas)
betas*2
head(betas)
betas*2
head(betas*2)
x <- 1
betas <- mvrnorm(1000, mu = c(3,5), Sigma = cov)
int <- betas*x
apply(int, 1, sum)
#Let us Assume the following model:
# beta1 mean = 3 with variance 1
# beta2 mean = 5 with variance 2.5
# beta1 and beta2 have a covariance of 1.25
cov <- matrix(data = c(1,1.25,1.25,2.5), nrow = 2, ncol = 2)
beta1 <- 3
beta2 <- 5
results <- c()
for (x in 1:100) {
y <- beta1*x + beta2*x
results[x] <- y
}
results2 <- c()
for (x in 1:100) {
betas <- mvrnorm(1000, mu = c(3,5), Sigma = cov)
int <- betas*x
int2 <- apply(int, 1, sum)
results2[x] <- mean(int2)
}
hist(results2)
plot(results, results2)
cov
mvrnorm(1000, mu = c(3,5), Sigma = cov)
#Let us Assume the following model:
# beta1 mean = 3 with variance 1
# beta2 mean = 5 with variance 2.5
# beta1 and beta2 have a covariance of 1.25
cov <- matrix(data = c(1,1.25,1.25,2.5), nrow = 2, ncol = 2)
beta1 <- 3
beta2 <- 5
results <- c()
for (x in 1:100) {
y <- beta1*x + beta2*x
results[x] <- y
}
results2 <- c()
for (x in 1:100) {
betas <- mvrnorm(1000, mu = c(3,5), Sigma = cov)
int <- betas*x
int2 <- apply(int, 1, sum)
results2[x] <- mean(int2)
}
plot(results, results2)
#### Set Up Environment ####
# Clear environment
rm(list = ls())
# Load Packages
library(pacman)
packages <- c('tidyverse','tmap','sp')
pacman::p_load(char = packages)
rm(packages)
# Define indicator family
indi_fam <- "water"
# Load data
if (!("pt_collapse" %in% ls())) {
name <- load('J:/LIMITED_USE/LU_GEOSPATIAL/geo_matched/wash/points_collapsed_2017_06_15.Rdata')
pt_collapse <- get(name)
}
head(pt_collapse)
names(pt_collapse)
name <- load('J:/LIMITED_USE/LU_GEOSPATIAL/geo_matched/wash/points_collapsed_2017_06_23.Rdata')
pt_collapse <- get(name)
name <- load('J:/LIMITED_USE/LU_GEOSPATIAL/geo_matched/wash/points_collapsed_2017_06_15.Rdata')
pt_collapse <- get(name)
names(pt_collapse)
#### Set Up Environment ####
# Clear environment
rm(list = ls())
# Load Packages
library(pacman)
packages <- c('tidyverse','tmap','sp')
pacman::p_load(char = packages)
rm(packages)
indi_fam <- "water"
data_type <- 'poly'
repo <- 'C:/Users/adesh/Documents/WASH/wash_code/'
if (!("pt_collapse" %in% ls()) & data_type == 'pt') {
name <- load('J:/LIMITED_USE/LU_GEOSPATIAL/geo_matched/wash/points_collapsed_2017_06_15.Rdata')
pt_collapse <- get(name)
}
if (!("pt_collapse" %in% ls()) & data_type == 'poly') {
name <- load('J:/LIMITED_USE/LU_GEOSPATIAL/geo_matched/wash/points_collapsed_2017_06_23.Rdata')
pt_collapse <- get(name)
}
rm(list = ls())
library(pacman)
packages <- c('tidyverse','tmap','sp')
pacman::p_load(char = packages)
rm(packages)
indi_fam <- "water"
data_type <- 'poly'
repo <- 'C:/Users/adesh/Documents/WASH/wash_code/'
if (!("pt_collapse" %in% ls()) & data_type == 'pt') {
name <- load('J:/LIMITED_USE/LU_GEOSPATIAL/geo_matched/wash/points_collapsed_2017_06_23.Rdata')
pt_collapse <- get(name)
}
if (!("pt_collapse" %in% ls()) & data_type == 'poly') {
name <- load('J:/LIMITED_USE/LU_GEOSPATIAL/geo_matched/wash/polys_collapsed_2017_06_23.Rdata')
pt_collapse <- get(name)
}
if (!("definitions" %in% ls())) {
if (indi_fam == "sani") {
definitions <- read_csv("J:/WORK/11_geospatial/wash/definitions/t_type_defined_updated_2017_05_25.csv",
progress = T, col_types = 'cc_')
} else {
definitions <- read_csv("J:/WORK/11_geospatial/wash/definitions/w_source_defined_updated_2017_05_24.csv",
progress = T, col_types = 'cc__')
definitions2 <- read_csv("J:/WORK/11_geospatial/wash/definitions/2nd_w_other_defined_updated_2017_05_18.csv",
progress = T, col_types = 'cc_')
definitions2 <- rename(definitions2, sdg2 = sdg)
}
}
rm(poly_collapse)
rm(list = ls())
library(pacman)
packages <- c('tidyverse','tmap','sp')
pacman::p_load(char = packages)
rm(packages)
indi_fam <- "water"
data_type <- 'poly'
repo <- 'C:/Users/adesh/Documents/WASH/wash_code/'
if (!("pt_collapse" %in% ls()) & data_type == 'pt') {
name <- load('J:/LIMITED_USE/LU_GEOSPATIAL/geo_matched/wash/points_collapsed_2017_06_23.Rdata')
pt_collapse <- get(name)
}
if (!("pt_collapse" %in% ls()) & data_type == 'poly') {
name <- load('J:/LIMITED_USE/LU_GEOSPATIAL/geo_matched/wash/polys_collapsed_2017_06_23.Rdata')
pt_collapse <- get(name)
rm(poly_collapse)
}
library(tidyverse)
polydat <- read_csv('J:/WORK/11_geospatial/wash/data/agg/water_poly_agg_2017_07_06.csv')
head(polydat)
polydat_loc <- filter(polydat, location_code == loc)
shp <- unique(polydat$shapefile)[1]
subset <- polydat[which(polydat$shapefile == shp),]
loc <- unique(subset$location_code)[1]
shape <- shape_master[shape_master$GAUL_CODE == loc,]
polydat_loc <- filter(polydat, location_code == loc)
polydat_loc
ptdat <- read_csv('J:/WORK/11_geospatial/wash/data/agg/water_pt_agg_2017_07_06.csv')
names(ptdat)
rm(list = ls())
root <- ifelse(Sys.info()[1]=="Windows", "J:/", "/home/j/")
package_list <- c('dplyr','raster', 'tiff', 'seegSDM','seegMBG')
if(Sys.info()[1]=="Windows") {
for(package in package_list) {
library(package, character.only = T)
}
} else {
package_lib <- paste0(root,'temp/geospatial/packages')
.libPaths(package_lib)
for(package in package_list) {
library(package, lib.loc = package_lib, character.only=TRUE)
}
}
install.packages(tiff)
install.packages('tiff')
# Set library and load packages
root <- ifelse(Sys.info()[1]=="Windows", "J:/", "/home/j/")
package_list <- c('dplyr','raster', 'tiff', 'seegSDM','seegMBG')
if(Sys.info()[1]=="Windows") {
for(package in package_list) {
library(package, character.only = T)
}
} else {
package_lib <- paste0(root,'temp/geospatial/packages')
.libPaths(package_lib)
for(package in package_list) {
library(package, lib.loc = package_lib, character.only=TRUE)
}
}
rm(list = ls())
indi_fam <- "water"
data_type <- 'pt'
agg_level <- 'country'
root <- ifelse(Sys.info()[1]=="Windows", "J:/", "/home/j/")
repo <- ifelse(Sys.info()[1]=="Windows", 'C:/Users/adesh/Documents/WASH/wash_code/01_collapse/',
'/share/code/geospatial/adesh/wash_mapping/01_collapse/')
package_list <- c('dplyr','readr')
if(Sys.info()[1]=="Windows") {
for(package in package_list) {
library(package, character.only = T)
}
} else {
package_lib <- paste0(root,'temp/geospatial/packages')
.libPaths(package_lib)
for(package in package_list) {
library(package, lib.loc = package_lib, character.only=TRUE)
}
}
library(readr)
rm(package_list)
if (!("pt_collapse" %in% ls()) & data_type == 'pt') {
name <- load(paste0(root,'LIMITED_USE/LU_GEOSPATIAL/geo_matched/wash/points_collapsed_2017_06_29.Rdata'))
pt_collapse <- get(name)
}
if (!("pt_collapse" %in% ls()) & data_type == 'poly') {
name <- load(paste0(root,'LIMITED_USE/LU_GEOSPATIAL/geo_matched/wash/polys_collapsed_2017_06_29.Rdata'))
pt_collapse <- get(name)
rm(poly_collapse)
}
if (!("definitions" %in% ls())) {
if (indi_fam == "sani") {
definitions <- read_csv(paste0(root,'WORK/11_geospatial/wash/definitions/t_type_defined_updated_2017_05_25.csv'),
progress = T, col_types = 'cc_')
} else {
definitions <- read_csv(paste0(root,'WORK/11_geospatial/wash/definitions/w_source_defined_updated_2017_05_24.csv'),
progress = T, col_types = 'cc__')
definitions2 <- read_csv(paste0(root,'WORK/11_geospatial/wash/definitions/2nd_w_other_defined_updated_2017_05_18.csv'),
progress = T, col_types = 'cc_')
definitions2 <- rename(definitions2, sdg2 = sdg)
}
}
rm(list = setdiff(ls(),c('definitions','pt_collapse','definitions2','indi_fam','repo','data_type','root','agg_level')))
setwd(repo)
source('functions/hh_cw.R')
source('functions/address_missing.R')
source('functions/cw_indi.R')
source('functions/agg_wash.R')
source('functions/define_wash.R')
rm(repo)
ptdat_0 <- dplyr::select(pt_collapse, nid, iso3, lat, long, survey_series, hhweight, urban, w_source_drink, w_source_other,
hh_size, year_start,hhweight,shapefile,location_code)
if (data_type == "pt" & agg_level != 'country') {ptdat$hhweight <- 1}
if (data_type == "pt") {ptdat$shapefile <- NA; ptdat$location_code <- NA}
if (data_type == 'pt') {
ptdat <- mutate(ptdat_0, cluster_id = paste(iso3, lat, long, survey_series, year_start, sep = "_"))
} else {
ptdat <- mutate(ptdat_0, cluster_id = paste(iso3, shapefile, location_code, survey_series, year_start, sep = "_"))
}
short_id <- data.frame(cluster_id = unique(ptdat$cluster_id),
id_short = seq(1:length(unique(ptdat$cluster_id))),
stringsAsFactors = F)
ptdat <- left_join(ptdat, short_id, by = 'cluster_id')
rm(short_id)
if (data_type == "pt" & agg_level != 'country') {ptdat$hhweight <- 1}
if (data_type == "pt") {ptdat$shapefile <- NA; ptdat$location_code <- NA}
ptdat <- dplyr::select(ptdat, -cluster_id)
ptdat <- define_indi()
ptdat <- rm_miss()
miss_wts <- unique(ptdat$id_short[which(is.na(ptdat$hhweight))])
ptdat <- filter(ptdat, !(id_short %in% miss_wts))
ptdat <- hh_cw(data = ptdat)
ptdat <- impute_indi()
ptdat <- agg_indi()
head(ptdat)
test <- filter(ptdat, iso3 == 'AGO')
test
agg_indi <- function(mydat = ptdat, var_family = indi_fam, dt_type = data_type, agg = agg_level) {
if (var_family == 'water') {
levels <- c('piped', 'surface','imp','unimp','bottled','bottled_sp','bottled_wl','well_cw',
'well_imp','well_unimp','spring_cw','spring_imp','spring_unimp')
}
if (var_family == 'sani') {
levels <- levels <- c('imp', 'imp_cw','shared','unimp','od','latrine_cw','latrine_imp','latrine_unimp')
}
results <- list()
for (i in levels) {
message(paste("Aggregating",i))
names(mydat)[which(names(mydat) == i)] <- 'indi'
if (dt_type == 'pt') {
if(agg == 'country') {
mydatresults <- mydat %>% mutate(wt_indi = hhweight*indi*hh_size, wt_denom = hhweight*hh_size) %>%
group_by(nid, iso3, survey_series, year_start) %>%
summarize(wtavg_indi = sum(wt_indi, na.rm = T)/sum(wt_denom, na.rm = T),
total_hh = sum(hh_size)) %>%
mutate(urban = NA)
} else {
mydatresults <- mydat %>% mutate(wt_indi = hhweight*indi*hh_size, wt_denom = hhweight*hh_size) %>%
group_by(id_short, nid, iso3, lat, long, survey_series, urban, year_start, shapefile, location_code) %>%
summarize(wtavg_indi = sum(wt_indi, na.rm = T)/sum(wt_denom, na.rm = T),
total_hh = sum(hh_size))
}
}
if (dt_type == 'poly') {
if(agg == 'country') {
mydatresults <- mydat %>% mutate(wt_indi = hhweight*indi*hh_size, wt_denom = hhweight*hh_size) %>%
group_by(nid, iso3, survey_series, year_start) %>%
summarize(wtavg_indi = sum(wt_indi, na.rm = T)/sum(wt_denom, na.rm = T),
total_hh = sum(hh_size)) %>%
mutate(urban = NA)
} else {
mydatresults <- mydat %>% mutate(wt_indi = hhweight*indi*hh_size, wt_denom = hhweight*hh_size) %>%
group_by(id_short, nid, iso3, lat, long, survey_series, year_start, shapefile, location_code) %>%
summarize(wtavg_indi = sum(wt_indi, na.rm = T)/sum(wt_denom, na.rm = T),
total_hh = sum(hh_size)) %>%
mutate(urban = NA)
}
}
names(mydatresults)[which(names(mydatresults) == 'wtavg_indi')] <- paste0(i)
results[[length(results)+1]] <- mydatresults
names(mydat)[which(names(mydat) == 'indi')] <- i
}
message("Merging all results...")
mydat <- Reduce(function(x,y) merge(x,y,all = T),results)
return(mydat)
}
if (data_type == 'pt') {
ptdat <- mutate(ptdat_0, cluster_id = paste(iso3, lat, long, survey_series, year_start, sep = "_"))
} else {
ptdat <- mutate(ptdat_0, cluster_id = paste(iso3, shapefile, location_code, survey_series, year_start, sep = "_"))
}
short_id <- data.frame(cluster_id = unique(ptdat$cluster_id),
id_short = seq(1:length(unique(ptdat$cluster_id))),
stringsAsFactors = F)
ptdat <- left_join(ptdat, short_id, by = 'cluster_id')
rm(short_id)
if (data_type == "pt" & agg_level != 'country') {ptdat$hhweight <- 1}
if (data_type == "pt") {ptdat$shapefile <- NA; ptdat$location_code <- NA}
ptdat <- dplyr::select(ptdat, -cluster_id)
ptdat <- define_indi()
ptdat <- rm_miss()
miss_wts <- unique(ptdat$id_short[which(is.na(ptdat$hhweight))])
ptdat <- filter(ptdat, !(id_short %in% miss_wts))
ptdat <- hh_cw(data = ptdat)
ptdat <- impute_indi()
ptdat <- agg_indi()
ptdat <- cw_indi()
message('CHECK ALL COLUMNS FOR VALID VALUES BEFORE EXPORTING')
print(unique(ptdat$iso3))
head(ptdat)
ptdat <- cw_indi()
source('functions/cw_indi.R')
ptdat <- cw_indi()
ptdat <- cw_indi()
head(ptdat)
if (agg_level == 'country') {
if (data_type == 'pt') {
write.csv(ptdat, paste0(root,'WORK/11_geospatial/wash/data/agg/water_pt_agg_cntry_',Sys.Date(),'.csv'))
} else {
write.csv(ptdat, paste0(root, 'WORK/11_geospatial/wash/data/agg/water_poly_agg_cntry_',Sys.Date(),'.csv'))
}
} else {
if (data_type == 'pt') {
write.csv(ptdat, paste0(root,'WORK/11_geospatial/wash/data/agg/water_pt_agg_',Sys.Date(),'.csv'))
} else {
write.csv(ptdat, paste0(root, 'WORK/11_geospatial/wash/data/agg/water_poly_agg_',Sys.Date(),'.csv'))
}
}
rm(list = ls())
indi_fam <- "water"
data_type <- 'poly'
agg_level <- 'country'
root <- ifelse(Sys.info()[1]=="Windows", "J:/", "/home/j/")
repo <- ifelse(Sys.info()[1]=="Windows", 'C:/Users/adesh/Documents/WASH/wash_code/01_collapse/',
'/share/code/geospatial/adesh/wash_mapping/01_collapse/')
package_list <- c('dplyr','readr')
if(Sys.info()[1]=="Windows") {
for(package in package_list) {
library(package, character.only = T)
}
} else {
package_lib <- paste0(root,'temp/geospatial/packages')
.libPaths(package_lib)
for(package in package_list) {
library(package, lib.loc = package_lib, character.only=TRUE)
}
}
library(readr)
rm(package_list)
if (!("pt_collapse" %in% ls()) & data_type == 'pt') {
name <- load(paste0(root,'LIMITED_USE/LU_GEOSPATIAL/geo_matched/wash/points_collapsed_2017_06_29.Rdata'))
pt_collapse <- get(name)
}
if (!("pt_collapse" %in% ls()) & data_type == 'poly') {
name <- load(paste0(root,'LIMITED_USE/LU_GEOSPATIAL/geo_matched/wash/polys_collapsed_2017_06_29.Rdata'))
pt_collapse <- get(name)
rm(poly_collapse)
}
if (!("definitions" %in% ls())) {
if (indi_fam == "sani") {
definitions <- read_csv(paste0(root,'WORK/11_geospatial/wash/definitions/t_type_defined_updated_2017_05_25.csv'),
progress = T, col_types = 'cc_')
} else {
definitions <- read_csv(paste0(root,'WORK/11_geospatial/wash/definitions/w_source_defined_updated_2017_05_24.csv'),
progress = T, col_types = 'cc__')
definitions2 <- read_csv(paste0(root,'WORK/11_geospatial/wash/definitions/2nd_w_other_defined_updated_2017_05_18.csv'),
progress = T, col_types = 'cc_')
definitions2 <- rename(definitions2, sdg2 = sdg)
}
}
rm(list = setdiff(ls(),c('definitions','pt_collapse','definitions2','indi_fam','repo','data_type','root','agg_level')))
setwd(repo)
source('functions/hh_cw.R')
source('functions/address_missing.R')
source('functions/cw_indi.R')
source('functions/agg_wash.R')
source('functions/define_wash.R')
rm(repo)
ptdat_0 <- dplyr::select(pt_collapse, nid, iso3, lat, long, survey_series, hhweight, urban, w_source_drink, w_source_other,
hh_size, year_start,hhweight,shapefile,location_code)
if (data_type == 'pt') {
ptdat <- mutate(ptdat_0, cluster_id = paste(iso3, lat, long, survey_series, year_start, sep = "_"))
} else {
ptdat <- mutate(ptdat_0, cluster_id = paste(iso3, shapefile, location_code, survey_series, year_start, sep = "_"))
}
short_id <- data.frame(cluster_id = unique(ptdat$cluster_id),
id_short = seq(1:length(unique(ptdat$cluster_id))),
stringsAsFactors = F)
ptdat <- left_join(ptdat, short_id, by = 'cluster_id')
rm(short_id)
if (data_type == "pt" & agg_level != 'country') {ptdat$hhweight <- 1}
if (data_type == "pt") {ptdat$shapefile <- NA; ptdat$location_code <- NA}
ptdat <- dplyr::select(ptdat, -cluster_id)
ptdat <- define_indi()
ptdat <- rm_miss()
miss_wts <- unique(ptdat$id_short[which(is.na(ptdat$hhweight))])
ptdat <- filter(ptdat, !(id_short %in% miss_wts))
ptdat <- hh_cw(data = ptdat)
ptdat <- impute_indi()
ptdat <- agg_indi()
ptdat <- cw_indi()
head(ptdat)
message('CHECK ALL COLUMNS FOR VALID VALUES BEFORE EXPORTING')
print(unique(ptdat$iso3))
if (agg_level == 'country') {
if (data_type == 'pt') {
write.csv(ptdat, paste0(root,'WORK/11_geospatial/wash/data/agg/water_pt_agg_cntry_',Sys.Date(),'.csv'))
} else {
write.csv(ptdat, paste0(root, 'WORK/11_geospatial/wash/data/agg/water_poly_agg_cntry_',Sys.Date(),'.csv'))
}
} else {
if (data_type == 'pt') {
write.csv(ptdat, paste0(root,'WORK/11_geospatial/wash/data/agg/water_pt_agg_',Sys.Date(),'.csv'))
} else {
write.csv(ptdat, paste0(root, 'WORK/11_geospatial/wash/data/agg/water_poly_agg_',Sys.Date(),'.csv'))
}
}
